__init__.py 保证该py所在的目录为package，在里面导入一些模块，其他地方可以从该包中导入这些模块。
如from wms.models import Dataset, Server, Variable, Style 这些包并不是在models目录中，而在更深的目录，不过在models目录中的__init__.py中导入。就可以直接用models
items()返回的是列表对象。而iteritems()返回的是iterator对象,在两者都可在for循环里使用。
pairs = dict.items()返回键值对的列表，是元组的列表噢
pairs = zip(d.keys(), d.values())
pairs = zip(d.iterkeys(), d.itervalues())
pairs = [(x,y) for (x,y) in d.iteritems()]

>>> a = dict(one=1, two=2, three=3)
>>> b = {'one': 1, 'two': 2, 'three': 3}
>>> c = dict(zip(['one', 'two', 'three'], [1, 2, 3]))
>>> d = dict([('two', 2), ('one', 1), ('three', 3)])
>>> e = dict({'three': 3, 'one': 1, 'two': 2})
>>> a == b == c == d == e
True

xrange 用法与 range 完全相同，所不同的是生成的不是一个list对象，而是一个生成器。在for里面两者结果一样，效率xrange更优
Python 没有块作用域。最小的范围是函数。for里用的变量在for外面也可以用
file_name='{}.html'.format(slug) #66666666加html
print('{}个红球,{}个黄球,{}个绿球'.format(a,b,c))
for i in ... i到最后一个不再+1
'ab:'.split(':') == ['ab','']

import a
dir(a)查看属性

实践证明，list和array作为参数获取.nc数据都可以！！！无区别
numpy netCDF4 参数可是列表也可是数组  a.variables['lon'][[1,2,3],[1],2,:]，都行！！！
b = a.variables['lon'][[1,2,3],[1],2,:]
b = b[:,:,:,index] index可以是array也可以是list
//整数整除 **幂
不能在数字前面添0
print(99,"ads","adsa")自动加空格和回车
type四种 bool、int、float、str  都可以强制转换 eg:str(1)
※字符串是不可变的，不能通过下标改。列表可以的
※index统统可以是正的也可以是负的
分片[start:end;step] 提取到end-1  end=-1则是提取到倒数第二个（包括他）为止 0是第一个，-1是最后一个！！分片不改变原列表
※字符串：len(str);list=str.split(',')分成列表，缺省是换行符、空格、字符包;str=','.join(list)变成字符串;str.startwith(substr)返回bool;str.find(substr)/rfind;str.count(substr);str.isalnum()判断是否全是字母或数字
str.replace(origin,target,count)最多修改count处 注意避免把所有的都换了
元组和列表不要求所含元素的种类相同
split出现连续的分隔符，会出现空元素。
列表不同与字符串，是可变的，通过下标改.列表允许相同的元素出现
※list.append(one_element);list1.extend(list2)或者list1+=list2;list.insert(index,one_element);del list[index]通过index删除;list.remove(element)通过内容删除（第一个）;list.pop()==list.pop(-1);list.index(element)返回index;list.count(element)出现的次数
sorted(list)list不变；list.sort()list改
变。默认升序
list或者tuple：a,b,c,d = list1分别赋值
list用等号相当于引用，标签。三种复制方法list1 = list2.copy();list1 = list(list2);list1 = list2[:]
☆字典的键不可变，所以必须是字符串或者元组。
字典直接赋值添加元素！！！
dict1.update(dict2)如果重复，dict2会取代dict1
dict.clear()删除所有；dict.get(key,"error output")没有的话输出error output；第二个参数缺省，不存在返回None不报错。通过下标键访问，不存在报错。
dict1.keys()，py2返回键的列表（python3返回dict_keys,需要显式调用list()来转换成列表）
※dict1.values();dict1.items()返回元组的列表。记住items是字典的！！！
in判断，list可以；dict可以，是判断键
set(dict1)只有键被作用
set中的交集运算符&,并集|，亦或^,还可以-，<=判断子集<判断真子集，返回bool。返回空集相当于false
---------------------
列表推导式[num for num in range(1,6) if num%2==1]
字典推导式(letter = 'letter')   [letter:word.count(letter) for letter in word]  优化[letter:word.count(letter) for letter in set(word)]
集合推导式 类似于列表推导式{}
元组没有推导式
(num for num in range(1,6))是生成器推导式，返回一个生成器对象。用list转换之只能转换一次
用if thing is None区分None和False
def function(*args):收集的是元组的形式。(**kwargs)收集的是字典
numpy: z.reshape(-1,2) 自动检测
matlab是一列中按行填充，numpy是一行中按列填充
numpy.reshape(a, newshape, order='C')默认按一行中的列填充
a[:,2,:]或者a[2,:]读取
def demo(name: str, age: 'int > 0'=20)->str:  # ->str 表示该函数的返回值是str类型的
a=a.astype(np.int16)改变numpy的类型
mu, sigma = 0, 0.1 可以这样赋值
p1=scipy.stats.norm.pdf(x, loc=0, scale=1) 代替matlab中normpdf 生成概率密度函数值
np.linspace(2.0, 3.0, num=5) 等间隔的数组，默认是包括最后的3的
fig.canvas.set_window_title('I am title') 窗口的标题
~True==-2 会判断true 只有0会判断False

