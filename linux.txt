Linux准确的来说是内核，但也用来代指内核+一大堆其他软件（工具和库）所构成的完整操作系统
POSIX（portable operating system interface，可移植操作系统接口）
电气和电子工程师协会（IEEE，全称是Institute of Electrical and Electronics Engineers）
内核：管理和分配计算机资源（CPU、RAM、设备）的核心层软件
CPU在两种不同的状态下运行：用户态和核心态
超级用户ID为0
init进程最牛逼，主要任务为创建并监控系统运行所需的一系列进程
文本、数据、堆、栈。fork之后只读文本由子父进程共享，其余的创建副本，互不影响
目标库：将通常是逻辑相关的一组函数代码加以编译，并置于一个文件中，供其他应用程序调用。
IPC进程间通信
☆系统调用将CPU从用户态切换到核心态，以便CPU访问受到保护的内核内存（重要表述）
一次系统调用一般大于0.3微妙。C语言返回的开销是系统调用的1/20。（例子）
调用系统调用xyz()等价于调用外壳函数(wrapper)，由wrapper函数去调用系统调用xyz()
GNU C语言函数库glibc
$ldd myprog | grep libc  针对某个与glibc动态链接的可执行文件，运行ldd找到依赖文件，再找libc。找到glibc的路径。
errno.h有几个。errno全局变量定义在其中一个.h文件中
read/write单位为字节
while((numRead=read(inputFd,buf,BUF_SIZE))>0)这里连续的read偏移量自动调整递进
lseek(fd,-1,SEEK_END);最后一个字节
lseek(fd,0,SEEK_CUR);返回现在的offset
文件描述符0,1,2是自带的，后面自己打开的文件其依次递增
文件不存在且未指定O_CREAT,错误。
☆open()调用的flag包括访问模式和状态标志
这些系统调用函数open/read/write/close/lseek/fcntl，错误统统返回-1。用errno来查看不同错误
exit(0)正常退出
用O_CREAT和O_EXCL标志来保持系统调用原子性.还有O_APPEND
ssize_t/mode_t/size_t都在<sys/types.h>中
fcntl.h定义了O_RDONLY等宏
fcntl这个函数很强大
O_RDONLY O_WRONLY ORDWR在open中不能同时使用
O_CREAT使用了，即使是只读也有效。此时必须提供mode参数提供权限
进程级的文件描述符表、系统级的打开文件表(句柄)、文件系统的i-node表
两个不同的文件描述符，若指向同一打开文件句柄，将共享同一文件偏移量
dup是用来指定新的文件描述符，指向同一打开文件句柄
进程下的所有线程将共享同一文件描述符表 
pread和pwrite在修改后offset处读写后立即恢复，不影响当前偏移量，用于多线程防止竞争
readv()分散输入和writev()集中输出(原子性一次性)
---------6进程-----------
进程由用户内存空间和一系列内核数据结构组成。内存空间包含了程序代码及代码变量，内核数据结构用于维护进程状态信息
pid到了32767重置300开始
PID在/proc里面
页大小通常4KB
clearenv()清除程序所引用所有环境变量(实际电脑存在)
栈：局部变量 、函数实参、返回值。
malloc基于8字节或者16字节边界来分配内存
进程终止时，其占用的所有内存都会返回给操作系统，包括malloc
--------8用户和组----------
每个文件和每个进程都有特定的用户ID和组ID
UID为0就是ROOT
[a-zA-Z0-9/.]
密码文件和shadow密码文件
pwd.h的struct passwd中的密码pw_passwd字段，在未启用shadow时才有效。一般都启用了shadow，pw_passwd无效，为x。转而看shadow.h中struct spwd中的sp_pwdp字段（一般会Permission denied，必须su）
------10时间12系统和进程信息-------------
t=time(NULL);返回自1970以来的秒数,time_t是一个有符号
pathname可以是当前的，也可以是/
/proc/PID和dev/fd
/proc虚拟的，因为其不存在与磁盘上，是内核在进程访问动态生成的
------13IO--------------
内核缓冲区高速缓存(kernel buffer cache)write和read不是直接搞定。
系统调用的开销：内核必须捕获调用，检查系统调用参数的有效性，在用户空间和内核空间之间传输数据
如果与文件发生大量的数据传输，采用大块空间缓冲数据、以及执行更少的系统调用，可以提升IO性能
int fflush(FILE *stream)输出将stdio缓冲区强制刷新到内核缓存，由内核缓存写。输入则丢弃已缓冲的
O_SYNC强制同步，每次调用write必须刷新到磁盘上才罢休。性能很差，因为将每个缓冲区数据向磁盘传递时会把程序阻塞
大多数linux文件系统不会记录文件的创建时间
struct stat文件的数据结构
文件创建时，其用户ID取自进程的有效用户ID，而组ID则取自进程的或父目录的组ID
※set-user-ID和set-group-ID不理解135页
i-node表的编号始于1
i-node条目可以是目录，标记目录类型
硬链接指向相同的i-node,删除一个另一个存在
硬链接必须在同一文件系统中。硬链接不能是目录。软链接全部反之
☆i-node不仅有链接计数(文件)，还有打开文件描述计数(进程)。仅当关闭所有文件描述符，方可删除一个已打开的文件(哪怕链接数为0)
